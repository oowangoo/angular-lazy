{"version":3,"sources":["register.js"],"names":["ModuleListenList","anonFn","appendModuleRequires","coverNgModule","createInvoke","getQueueArguments","hitCache","initRegisterCache","isRegister","moduleProxy","nextTick","putRegisterCache","register","registerCache","angular","module","isBootstrap","moduleName","ng","method","_i","_len","_results","length","push","args","fn","name","isDefined","isArray","toString","cache","caches","indexOf","$isProxy","invokeQueue","normal","isFunction","Error","result","arguments","apply","requires","appendList","baseRequires","req","Array","prototype","normalModule","delay","setTimeout","directive","restrict","compile","provider","$provide","$controllerProvider","$compileProvider","$filterProvider","$injector","$animateProvider","invokeLater","providerCache","providers","registerFunction","runLater","self","this","getInstanceInjector","injector","pname","rs","block","instance","invoke","factory","service","value","constant","animation","filter","controller","config","run","rFn","$get","$rootElement","instanceInjector","data","call"],"mappings":"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","file":"register.min.js","sourcesContent":["(function() {\n  var ModuleListenList, anonFn, appendModuleRequires, coverNgModule, createInvoke, getQueueArguments, hitCache, initRegisterCache, isRegister, moduleProxy, nextTick, putRegisterCache, register, registerCache;\n\n  register = angular.module('angular.lazy.register', ['ng']);\n\n  register.isBootstrap = false;\n\n  register.isRegister = isRegister = function(moduleName) {\n    return !!registerCache.module[moduleName];\n  };\n\n  ModuleListenList = ['provider', 'factory', 'service', 'value', 'constant', 'animation', 'filter', 'controller', 'directive', 'config', 'run'];\n\n  registerCache = {\n    module: {\n      'ng': true\n    }\n  };\n\n  initRegisterCache = function() {\n    var method, _i, _len, _results;\n    registerCache = {\n      module: {\n        'ng': true\n      }\n    };\n    _results = [];\n    for (_i = 0, _len = ModuleListenList.length; _i < _len; _i++) {\n      method = ModuleListenList[_i];\n      _results.push(registerCache[method] = {});\n    }\n    return _results;\n  };\n\n  initRegisterCache();\n\n  getQueueArguments = function(args) {\n    var fn, name;\n    name = args[0];\n    fn = args[1];\n    if (!angular.isDefined(fn)) {\n      fn = name;\n      name = '@';\n    }\n    if (angular.isArray(fn)) {\n      fn = fn[fn.length - 1];\n    }\n    return {\n      name: name,\n      fn: fn\n    };\n  };\n\n  anonFn = function(fn) {\n    return fn.toString();\n  };\n\n  hitCache = function(method, args) {\n    var cache, caches, fn, name;\n    caches = registerCache[method];\n    args = getQueueArguments(args);\n    name = args.name;\n    fn = args.fn;\n    cache = caches[name];\n    if (!cache) {\n      return false;\n    }\n    if (!angular.isArray(cache)) {\n      return true;\n    }\n    return cache.indexOf(anonFn(fn)) > -1;\n  };\n\n  putRegisterCache = function(method, args) {\n    var caches, fn, name;\n    caches = registerCache[method];\n    args = getQueueArguments(args);\n    name = args.name;\n    fn = args.fn;\n    if (['run', 'config', 'directive'].indexOf(method) > -1) {\n      caches[name] = caches[name] || [];\n      caches[name].push(anonFn(fn));\n    } else {\n      caches[name] = true;\n    }\n  };\n\n  moduleProxy = function(module) {\n    var method, _i, _len;\n    registerCache.module[module.name] = true;\n    for (_i = 0, _len = ModuleListenList.length; _i < _len; _i++) {\n      method = ModuleListenList[_i];\n      module[method] = createInvoke(module, method);\n    }\n    module.$isProxy = true;\n    return module;\n  };\n\n  createInvoke = function(module, method) {\n    var invokeQueue, normal;\n    normal = module[method];\n    if (!normal || !angular.isFunction(normal)) {\n      throw new Error(\"badmethod  no method \" + method + \" name\");\n    }\n    invokeQueue = function() {\n      var result;\n      if (hitCache(method, arguments)) {\n        return module;\n      }\n      result = normal.apply(module, arguments);\n      putRegisterCache(method, arguments);\n      if (register.isBootstrap) {\n        register.register(module, method, arguments);\n      }\n      return result;\n    };\n    return invokeQueue;\n  };\n\n  appendModuleRequires = function(moduleName, requires) {\n    var appendList, baseRequires, module, req, _i, _len;\n    module = angular.module(moduleName);\n    baseRequires = module.requires;\n    appendList = [];\n    for (_i = 0, _len = requires.length; _i < _len; _i++) {\n      req = requires[_i];\n      if (baseRequires.indexOf(req) === -1) {\n        appendList.push(req);\n      }\n    }\n    Array.prototype.push.apply(baseRequires, appendList);\n    return module;\n  };\n\n  coverNgModule = function() {\n    var normalModule;\n    normalModule = angular.module;\n    return angular.module = function(name, requires, fn) {\n      var module;\n      if (requires && isRegister(name)) {\n        return appendModuleRequires(name, requires);\n      }\n      module = normalModule(name, requires, fn);\n      if (module.$isProxy) {\n        return module;\n      }\n      return moduleProxy(module);\n    };\n  };\n\n  nextTick = function(fn, delay) {\n    return setTimeout(fn, delay || 0);\n  };\n\n  register.directive(\"body\", [\n    function() {\n      return {\n        restrict: \"E\",\n        compile: function() {\n          return register.isBootstrap = true;\n        }\n      };\n    }\n  ]).provider(\"register\", [\n    \"$provide\", \"$controllerProvider\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function($provide, $controllerProvider, $compileProvider, $filterProvider, $injector, $animateProvider) {\n      var invokeLater, providerCache, providers, registerFunction, runLater, self;\n      self = this;\n      providerCache = {};\n      providers = {\n        $provide: $provide,\n        $controllerProvider: $controllerProvider,\n        $compileProvider: $compileProvider,\n        $filterProvider: $filterProvider,\n        $injector: $injector,\n        $animateProvider: $animateProvider,\n        getInstanceInjector: function() {\n          return angular.injector();\n        }\n      };\n      invokeLater = function(pname, method) {\n        var provider;\n        provider = providers[pname];\n        if (!provider) {\n          throw new Error(\"badProvider unsupported provider \" + pname);\n        }\n        return function() {\n          var rs;\n          rs = provider[method].apply(provider, arguments);\n        };\n      };\n      runLater = function() {\n        return function(block) {\n          var instance;\n          instance = providers.getInstanceInjector();\n          return nextTick(function() {\n            return instance.invoke(block);\n          });\n        };\n      };\n      registerFunction = {\n        provider: invokeLater('$provide', 'provider'),\n        factory: invokeLater('$provide', 'factory'),\n        service: invokeLater('$provide', 'service'),\n        value: invokeLater('$provide', 'value'),\n        constant: invokeLater('$provide', 'constant', 'unshift'),\n        animation: invokeLater('$animateProvider', 'register'),\n        filter: invokeLater('$filterProvider', 'register'),\n        controller: invokeLater('$controllerProvider', 'register'),\n        directive: invokeLater('$compileProvider', 'directive'),\n        config: invokeLater('$injector', 'invoke', 'push', \"_configBlocks\"),\n        run: runLater()\n      };\n      register.register = function(module, method, args) {\n        var rFn;\n        rFn = registerFunction[method];\n        if (!rFn) {\n          throw new Error(\"badFunctioin unsupproted register \" + method);\n        }\n        rFn.apply(this, args);\n      };\n      this.$get = [\n        '$rootElement', function($rootElement) {\n          var instanceInjector;\n          instanceInjector = null;\n          providers.getInstanceInjector = function() {\n            if (!instanceInjector) {\n              instanceInjector = $rootElement.data('$injector') || angular.injector();\n            }\n            return instanceInjector;\n          };\n          return register.register;\n        }\n      ];\n      return this;\n    }\n  ]).run(['register', function(service) {}]);\n\n  coverNgModule();\n\n}).call(this);\n"]}