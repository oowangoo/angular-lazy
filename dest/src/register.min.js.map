{"version":3,"sources":["register.js"],"names":["ModuleListenList","anonFn","appendModuleRequires","coverNgModule","createInvoke","getQueueArguments","hitCache","initRegisterCache","isRegister","moduleProxy","nextTick","putRegisterCache","register","registerCache","angular","module","isBootstrap","moduleName","ng","method","_i","_len","_results","length","push","args","fn","name","isArray","toString","cache","caches","indexOf","$isProxy","invokeQueue","normal","isFunction","Error","result","arguments","apply","requires","appendList","baseRequires","req","Array","prototype","normalModule","delay","setTimeout","directive","restrict","compile","provider","$provide","$controllerProvider","$compileProvider","$filterProvider","$injector","$animateProvider","invokeLater","providerCache","providers","registerFunction","runLater","self","this","getInstanceInjector","injector","pname","rs","block","instance","invoke","factory","service","value","constant","animation","filter","controller","config","run","rFn","$get","$rootElement","instanceInjector","data","call"],"mappings":"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","file":"register.min.js","sourcesContent":["(function() {\n  var ModuleListenList, anonFn, appendModuleRequires, coverNgModule, createInvoke, getQueueArguments, hitCache, initRegisterCache, isRegister, moduleProxy, nextTick, putRegisterCache, register, registerCache;\n\n  register = angular.module('angular.lazy.register', ['ng']);\n\n  register.isBootstrap = false;\n\n  register.isRegister = isRegister = function(moduleName) {\n    return !!registerCache.module[moduleName];\n  };\n\n  ModuleListenList = ['provider', 'factory', 'service', 'value', 'constant', 'animation', 'filter', 'controller', 'directive', 'config', 'run'];\n\n  registerCache = {\n    module: {\n      'ng': true\n    }\n  };\n\n  initRegisterCache = function() {\n    var method, _i, _len, _results;\n    registerCache = {\n      module: {\n        'ng': true\n      }\n    };\n    _results = [];\n    for (_i = 0, _len = ModuleListenList.length; _i < _len; _i++) {\n      method = ModuleListenList[_i];\n      _results.push(registerCache[method] = {});\n    }\n    return _results;\n  };\n\n  initRegisterCache();\n\n  getQueueArguments = function(args) {\n    var fn, name;\n    name = args[0];\n    fn = args[1];\n    if (!fn) {\n      fn = name;\n      name = '@';\n    }\n    if (angular.isArray(fn)) {\n      fn = fn[fn.length - 1];\n    }\n    return {\n      name: name,\n      fn: fn\n    };\n  };\n\n  anonFn = function(fn) {\n    return fn.toString();\n  };\n\n  hitCache = function(method, args) {\n    var cache, caches, fn, name;\n    caches = registerCache[method];\n    args = getQueueArguments(args);\n    name = args.name;\n    fn = args.fn;\n    cache = caches[name];\n    if (!cache) {\n      return false;\n    }\n    if (!angular.isArray(cache)) {\n      return true;\n    }\n    return cache.indexOf(anonFn(fn)) > -1;\n  };\n\n  putRegisterCache = function(method, args) {\n    var caches, fn, name;\n    caches = registerCache[method];\n    args = getQueueArguments(args);\n    name = args.name;\n    fn = args.fn;\n    if (['run', 'config', 'directive'].indexOf(method) > -1) {\n      caches[name] = caches[name] || [];\n      caches[name].push(anonFn(fn));\n    } else {\n      caches[name] = true;\n    }\n  };\n\n  moduleProxy = function(module) {\n    var method, _i, _len;\n    registerCache.module[module.name] = true;\n    for (_i = 0, _len = ModuleListenList.length; _i < _len; _i++) {\n      method = ModuleListenList[_i];\n      module[method] = createInvoke(module, method);\n    }\n    module.$isProxy = true;\n    return module;\n  };\n\n  createInvoke = function(module, method) {\n    var invokeQueue, normal;\n    normal = module[method];\n    if (!normal || !angular.isFunction(normal)) {\n      throw new Error(\"badmethod  no method \" + method + \" name\");\n    }\n    invokeQueue = function() {\n      var result;\n      if (hitCache(method, arguments)) {\n        return module;\n      }\n      result = normal.apply(module, arguments);\n      putRegisterCache(method, arguments);\n      if (register.isBootstrap) {\n        register.register(module, method, arguments);\n      }\n      return result;\n    };\n    return invokeQueue;\n  };\n\n  appendModuleRequires = function(moduleName, requires) {\n    var appendList, baseRequires, module, req, _i, _len;\n    module = angular.module(moduleName);\n    baseRequires = module.requires;\n    appendList = [];\n    for (_i = 0, _len = requires.length; _i < _len; _i++) {\n      req = requires[_i];\n      if (baseRequires.indexOf(req) === -1) {\n        appendList.push(req);\n      }\n    }\n    Array.prototype.push.apply(baseRequires, appendList);\n    return module;\n  };\n\n  coverNgModule = function() {\n    var normalModule;\n    normalModule = angular.module;\n    return angular.module = function(name, requires, fn) {\n      var module;\n      if (requires && isRegister(name)) {\n        return appendModuleRequires(name, requires);\n      }\n      module = normalModule(name, requires, fn);\n      if (module.$isProxy) {\n        return module;\n      }\n      return moduleProxy(module);\n    };\n  };\n\n  nextTick = function(fn, delay) {\n    return setTimeout(fn, delay || 0);\n  };\n\n  register.directive(\"body\", [\n    function() {\n      return {\n        restrict: \"E\",\n        compile: function() {\n          return register.isBootstrap = true;\n        }\n      };\n    }\n  ]).provider(\"register\", [\n    \"$provide\", \"$controllerProvider\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function($provide, $controllerProvider, $compileProvider, $filterProvider, $injector, $animateProvider) {\n      var invokeLater, providerCache, providers, registerFunction, runLater, self;\n      self = this;\n      providerCache = {};\n      providers = {\n        $provide: $provide,\n        $controllerProvider: $controllerProvider,\n        $compileProvider: $compileProvider,\n        $filterProvider: $filterProvider,\n        $injector: $injector,\n        $animateProvider: $animateProvider,\n        getInstanceInjector: function() {\n          return angular.injector();\n        }\n      };\n      invokeLater = function(pname, method) {\n        var provider;\n        provider = providers[pname];\n        if (!provider) {\n          throw new Error(\"badProvider unsupported provider \" + pname);\n        }\n        return function() {\n          var rs;\n          rs = provider[method].apply(provider, arguments);\n        };\n      };\n      runLater = function() {\n        return function(block) {\n          var instance;\n          instance = providers.getInstanceInjector();\n          return nextTick(function() {\n            return instance.invoke(block);\n          });\n        };\n      };\n      registerFunction = {\n        provider: invokeLater('$provide', 'provider'),\n        factory: invokeLater('$provide', 'factory'),\n        service: invokeLater('$provide', 'service'),\n        value: invokeLater('$provide', 'value'),\n        constant: invokeLater('$provide', 'constant', 'unshift'),\n        animation: invokeLater('$animateProvider', 'register'),\n        filter: invokeLater('$filterProvider', 'register'),\n        controller: invokeLater('$controllerProvider', 'register'),\n        directive: invokeLater('$compileProvider', 'directive'),\n        config: invokeLater('$injector', 'invoke', 'push', \"_configBlocks\"),\n        run: runLater()\n      };\n      register.register = function(module, method, args) {\n        var rFn;\n        rFn = registerFunction[method];\n        if (!rFn) {\n          throw new Error(\"badFunctioin unsupproted register \" + method);\n        }\n        rFn.apply(this, args);\n      };\n      this.$get = [\n        '$rootElement', function($rootElement) {\n          var instanceInjector;\n          instanceInjector = null;\n          providers.getInstanceInjector = function() {\n            if (!instanceInjector) {\n              instanceInjector = $rootElement.data('$injector') || angular.injector();\n            }\n            return instanceInjector;\n          };\n          return register.register;\n        }\n      ];\n      return this;\n    }\n  ]).run(['register', function(service) {}]);\n\n  coverNgModule();\n\n}).call(this);\n"]}